/**
 * @file qp_demo.c
 * @brief QP Utils demonstration implementation
 */

#include "qp_demo.h"

// ============================================================================
// Global State
// ============================================================================

static painter_device_t display = NULL;
static qp_demo_mode_t current_mode = DEMO_MODE_BASIC;
static uint32_t last_update = 0;
static uint32_t mode_start_time = 0;

// ============================================================================
// Placeholder Image Data
// ============================================================================

// Simple 8x8 placeholder icons (monochrome)
static const uint8_t PROGMEM placeholder_icon_8x8[] = {
    0x3C, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3C
};

static const uint8_t PROGMEM placeholder_spinner1_8x8[] = {
    0x18, 0x24, 0x42, 0x81, 0x81, 0x42, 0x24, 0x18
};

static const uint8_t PROGMEM placeholder_spinner2_8x8[] = {
    0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81
};

// Note: These are placeholder raw bitmap data
// In a real implementation, you would use QGF files generated by:
// qmk painter-convert-graphics -f mono2 -i icon.png -o ./generated/

// ============================================================================
// Forward Declarations
// ============================================================================

static void qp_demo_update_basic_mode(uint32_t now);
static void qp_demo_update_animation_mode(uint32_t now);
static void qp_demo_update_widgets_mode(uint32_t now);
static void qp_demo_update_stress_mode(uint32_t now);
static void qp_demo_update_status_bar(const char* mode_text);

// ============================================================================
// Demo Implementation
// ============================================================================

bool qp_demo_init(void) {
    // Initialize SH1106 I2C display (128x64 monochrome OLED)
    display = qp_sh1106_make_i2c_device(128, 64, 0x3C);
    
    if (!qp_init(display, QP_ROTATION_0)) {
        return false;
    }
    
    if (!qp_utils_init(display)) {
        return false;
    }
    
    qp_power(display, true);
    
    // Clear display and draw initial frame
    qp_clear_rect(display, 0, 0, DEMO_DISPLAY_WIDTH, DEMO_DISPLAY_HEIGHT);
    
    // Draw header
    qp_fill_rect(display, 0, 0, DEMO_DISPLAY_WIDTH, DEMO_HEADER_HEIGHT, QP_COLOR_WHITE);
    qp_fill_rect(display, 2, 2, DEMO_DISPLAY_WIDTH - 4, DEMO_HEADER_HEIGHT - 4, QP_COLOR_BLACK);
    
    // Draw border around main area
    qp_draw_rect(display, 0, DEMO_MAIN_Y, DEMO_DISPLAY_WIDTH, DEMO_MAIN_HEIGHT, QP_COLOR_WHITE);
    
    mode_start_time = timer_read32();
    return true;
}

void qp_demo_update(void) {
    if (!display) return;
    
    uint32_t now = timer_read32();
    
    // Update display every 50ms
    if (TIMER_DIFF_32(now, last_update) >= 50) {
        switch (current_mode) {
            case DEMO_MODE_BASIC:
                qp_demo_update_basic_mode(now);
                break;
            case DEMO_MODE_ANIMATION:
                qp_demo_update_animation_mode(now);
                break;
            case DEMO_MODE_WIDGETS:
                qp_demo_update_widgets_mode(now);
                break;
            case DEMO_MODE_STRESS:
                qp_demo_update_stress_mode(now);
                break;
            default:
                break;
        }
        
        last_update = now;
    }
    
    // Auto-cycle modes every 10 seconds for demo
    if (TIMER_DIFF_32(now, mode_start_time) >= 10000) {
        qp_demo_cycle_mode();
    }
}

static void qp_demo_update_basic_mode(uint32_t now) {
    // Clear main area
    qp_clear_rect(display, 2, DEMO_MAIN_Y + 2, DEMO_DISPLAY_WIDTH - 4, DEMO_MAIN_HEIGHT - 4);
    
    // Draw current layer indicator
    uint8_t layer = get_highest_layer(layer_state);
    qp_demo_draw_layer_indicator(layer);
    
    // Draw modifier status
    uint8_t mods = get_mods() | get_oneshot_mods();
    qp_demo_draw_modifier_status(mods);
    
    // Draw WPM if available
    #ifdef WPM_ENABLE
    qp_demo_draw_wpm(get_current_wpm());
    #endif
    
    // Draw caps lock status
    qp_demo_draw_caps_lock(host_keyboard_led_state().caps_lock);
    
    // Update status bar
    qp_demo_update_status_bar("BASIC MODE");
}

static void qp_demo_update_animation_mode(uint32_t now) {
    // Clear main area
    qp_clear_rect(display, 2, DEMO_MAIN_Y + 2, DEMO_DISPLAY_WIDTH - 4, DEMO_MAIN_HEIGHT - 4);
    
    // Draw animated spinner (simple frame-based animation)
    static uint8_t frame = 0;
    static uint32_t last_frame_time = 0;
    
    if (TIMER_DIFF_32(now, last_frame_time) >= 200) {
        frame = (frame + 1) % 4;
        last_frame_time = now;
    }
    
    // Draw spinner frames using basic shapes
    uint16_t center_x = DEMO_DISPLAY_WIDTH / 2;
    uint16_t center_y = DEMO_MAIN_Y + DEMO_MAIN_HEIGHT / 2;
    
    switch (frame) {
        case 0:
            qp_draw_hline(display, center_x - 5, center_x + 5, center_y, QP_COLOR_WHITE);
            break;
        case 1:
            qp_draw_vline(display, center_x, center_y - 5, center_y + 5, QP_COLOR_WHITE);
            break;
        case 2:
            qp_draw_hline(display, center_x - 5, center_x + 5, center_y, QP_COLOR_WHITE);
            break;
        case 3:
            qp_draw_vline(display, center_x, center_y - 5, center_y + 5, QP_COLOR_WHITE);
            break;
    }
    
    qp_demo_update_status_bar("ANIMATION MODE");
}

static void qp_demo_update_widgets_mode(uint32_t now) {
    // This would demonstrate declarative widgets
    // For now, show a placeholder
    qp_clear_rect(display, 2, DEMO_MAIN_Y + 2, DEMO_DISPLAY_WIDTH - 4, DEMO_MAIN_HEIGHT - 4);
    
    // Draw widget placeholder
    qp_fill_rect(display, 10, DEMO_MAIN_Y + 10, 20, 10, QP_COLOR_WHITE);
    qp_fill_rect(display, 40, DEMO_MAIN_Y + 10, 20, 10, QP_COLOR_WHITE);
    qp_fill_rect(display, 70, DEMO_MAIN_Y + 10, 20, 10, QP_COLOR_WHITE);
    
    qp_demo_update_status_bar("WIDGETS MODE");
}

static void qp_demo_update_stress_mode(uint32_t now) {
    // Performance stress test
    qp_clear_rect(display, 2, DEMO_MAIN_Y + 2, DEMO_DISPLAY_WIDTH - 4, DEMO_MAIN_HEIGHT - 4);
    
    // Draw many small rectangles
    for (int i = 0; i < 20; i++) {
        uint16_t x = (i * 6) % (DEMO_DISPLAY_WIDTH - 10);
        uint16_t y = DEMO_MAIN_Y + 5 + ((i / 10) * 8);
        qp_fill_rect(display, x, y, 4, 4, QP_COLOR_WHITE);
    }
    
    qp_demo_update_status_bar("STRESS TEST");
}

static void qp_demo_update_status_bar(const char* mode_text) {
    // Clear status area
    qp_clear_rect(display, 0, DEMO_STATUS_Y, DEMO_DISPLAY_WIDTH, DEMO_STATUS_HEIGHT);
    
    // Draw status background
    qp_draw_rect(display, 0, DEMO_STATUS_Y, DEMO_DISPLAY_WIDTH, DEMO_STATUS_HEIGHT, QP_COLOR_WHITE);
    
    // Show mode indicator (simple dots)
    for (int i = 0; i < DEMO_MODE_COUNT; i++) {
        uint16_t x = 5 + (i * 8);
        uint16_t y = DEMO_STATUS_Y + 4;
        if (i == current_mode) {
            qp_fill_rect(display, x, y, 4, 4, QP_COLOR_WHITE);
        } else {
            qp_draw_rect(display, x, y, 4, 4, QP_COLOR_WHITE);
        }
    }
}

void qp_demo_draw_layer_indicator(uint8_t layer) {
    // Draw layer indicator in top-left of main area
    uint16_t x = 5;
    uint16_t y = DEMO_MAIN_Y + 5;
    
    for (int i = 0; i < 4; i++) {
        if (i == layer) {
            qp_fill_rect(display, x + (i * 8), y, 6, 6, QP_COLOR_WHITE);
        } else {
            qp_draw_rect(display, x + (i * 8), y, 6, 6, QP_COLOR_WHITE);
        }
    }
}

void qp_demo_draw_modifier_status(uint8_t mods) {
    // Draw modifier status in top-right of main area
    uint16_t x = DEMO_DISPLAY_WIDTH - 40;
    uint16_t y = DEMO_MAIN_Y + 5;
    
    if (mods & MOD_MASK_SHIFT) {
        qp_fill_rect(display, x, y, 6, 6, QP_COLOR_WHITE);
    }
    if (mods & MOD_MASK_CTRL) {
        qp_fill_rect(display, x + 8, y, 6, 6, QP_COLOR_WHITE);
    }
    if (mods & MOD_MASK_ALT) {
        qp_fill_rect(display, x + 16, y, 6, 6, QP_COLOR_WHITE);
    }
    if (mods & MOD_MASK_GUI) {
        qp_fill_rect(display, x + 24, y, 6, 6, QP_COLOR_WHITE);
    }
}

void qp_demo_draw_wpm(uint8_t wpm) {
    // Draw WPM bar graph
    uint16_t x = 10;
    uint16_t y = DEMO_MAIN_Y + 20;
    uint16_t max_width = 100;
    uint16_t bar_width = (wpm * max_width) / 100; // Scale to 0-100 WPM
    
    if (bar_width > max_width) bar_width = max_width;
    
    qp_draw_rect(display, x, y, max_width, 8, QP_COLOR_WHITE);
    if (bar_width > 0) {
        qp_fill_rect(display, x + 1, y + 1, bar_width - 2, 6, QP_COLOR_WHITE);
    }
}

void qp_demo_draw_caps_lock(bool caps_on) {
    // Draw caps lock indicator
    uint16_t x = DEMO_DISPLAY_WIDTH - 15;
    uint16_t y = DEMO_MAIN_Y + 20;
    
    if (caps_on) {
        qp_fill_rect(display, x, y, 10, 8, QP_COLOR_WHITE);
    } else {
        qp_draw_rect(display, x, y, 10, 8, QP_COLOR_WHITE);
    }
}

void qp_demo_cycle_mode(void) {
    current_mode = (current_mode + 1) % DEMO_MODE_COUNT;
    mode_start_time = timer_read32();
    
    // Clear main area when switching modes
    if (display) {
        qp_clear_rect(display, 2, DEMO_MAIN_Y + 2, DEMO_DISPLAY_WIDTH - 4, DEMO_MAIN_HEIGHT - 4);
    }
}

uint8_t qp_demo_get_mode(void) {
    return current_mode;
}
